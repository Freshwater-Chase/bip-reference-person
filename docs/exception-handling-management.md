#OCP Exception Management
This docoument is primarily concerned with exceptions generated in the course of executing business processes in the service and partner layers. For discussion of input validations, see [validation-management.md](./validation-management.md).

##Layer Concerns
Each layer of an OCP micro-service has different exception handling needs. Understanding layer concerns is necessary.

Associated patterns and implementation details are discussed later.

###Provider Concerns
The Provider (REST/API) layer must catch all Throwables and convert them to appropriate response messages:
- Must catch and handle exceptions that could be thrown in the frameworks and libraries used for protocol handling, deserialization/transformation, etc.
- Must catch and handle exceptions propagated from other layers in the service application.
- Response messages must be meaningful to the service consumer and the maintainers (support/development staff).
- The Provider layer must have enough information to determine appropriate severity, HTTP status codes, message keys, and text.

###Service Concerns
The Service (domain/business) layers may generate exceptions during execution, and may receive exceptions from external entities and external clients.

The business layers must be able to identify and categorize exceptions before allowing them to propagate to the Provider layer.

###Client Concerns
The Partner (external/3rd party) client may encounter a variety of exceptions that occur due to:
- Issues out of the control of the application, such as network problems, partner service problems, etc. These typically resolve to some form of 500-series http status code.
- Bugs in the partner client coding or schema interpretation should also be surfaced as 500-series codes.
- Request related problems that indicate some issue with the **input data**, such as invalid or malformed input, or requested data not found.
- Environment/System related problems beyond control of the application such as glitching network, failing hardware, service unavailable, etc.

##Exception Types
- `OcpRuntimeException` and sub-classes identify known conditions in which the exception should immediately propagate back to the Provider layer. Examples include validation voilations, data not found, and other 400-series conditions under which processing should be aborted.
- `OcpException` and sub-classes are checked exceptions that identify known conditions requiring some intervention or decision by the application logic. These exceptions might:
	- be handled, and processing allowed to continue;
	- be transformed to an OcpRuntimeException and propagated immediately to the Provider layer. 
- All other exceptions, whether runtime or checked, are assumed to have originated from outside the application. Depending on the scenario and context, these would typically be candidates for 500-series handling.

##Exception Handling Patterns

###Provider Pattern
- Spring `@RestControllerAdvice` interceptor/aspect is used ...
	* Implemented in `OcpRestGlobalExceptionHandler`. In this class, each `@ExceptionHandler(value={ `*exception*`.class`*,...*` })` catches the specified exception(s) and formulates the message and the HTTP `@ResponseStatus` to be returned to the consumer.
	* Spring processes `@ExceptionHandler` methods in the order they appear in the class, much like a try/catch block. The methods must appear in order from most specific to most general.
- Auto-configured by `OcpRestAutoConfiguration`. 

###Service Patterns
- Subclass OCP exception types to help identify specific handling requirements.
- To the extent possible, convert non-OCP exception types to OCP exception types, with appropriate content.
- Exceptions directly generated by the service layer should:
	* Be `OcpRuntimeException` or sub-class if it is an issue that should immediately propagate back to the provider layer.
	* Be `OcpException` or sub-class only if additional actions or decisions are required in order to resume execution.
- The service impl *may* need to capture checked exceptions thrown from client operations and take specific actions or convert them. It should be rare that a service would need to catch runtime exceptions.
- The service helper (e.g. `PersonPartnerHelper`) *may* need to catch non-OCP partner exceptions, and and convert them to and appropriate OCP exception type.

###Client Patterns

####SOAP Partner Clients
- Spring AOP `ThrowsAdvise` implementation is provided in `InterceptingExceptionTranslator`
	- the intercepetor is made available for configuring clients in `BaseWsClientConfig.getInterceptingExceptionTranslator()`.
	- Any client implementataion of `BaseWsClientConfig` should configure a spring bean that gets the InterceptingExceptionTranslator. For example, see [PersonWsClientConfig.personWsClientExceptionInterceptor()](https://github.com/department-of-veterans-affairs/ocp-reference-spring-boot/blob/master/ocp-reference-partner-person/src/main/java/gov/va/ocp/reference/partner/person/ws/client/PersonWsClientConfig.java)
	- The interceptor allows any exception under `gov.va.ocp.framework.exception` to propagate untouched. All other exceptions are converted to `OcpRuntimeException`. **Therefore** any exceptions that *should* propagate as checked exceptions *must* be thrown (or re-thrown) by the WsClientImpl as `OcpException`.
- **Rules** for implementers of `RemoteServiceCall` (e.g. .\*RemoteServiceCallImpl, .\*RemoteServiceCallMock):
	* Allow **all** exceptions to propagate as-is.
- **Rules** for implementers of `BaseWsClientImpl`:
	* Allow all partner exceptions that arise due to natural data issues (e.g. soap:fault raised due to "not found", "unknown format", etc) to propagate as-is. The interceptor (see below) will convert them to OcpRuntimeExceptions so they can be dealt with as validation-style exceptions.
	* *May* need to convert some partner exceptions that arise due to their own internal issues (e.g. database down, etc). These should be converted to `OcpException` or sub-class so they can propagate to the service impl (or the provider handler) as known checked exceptions.

####REST & Feign Clients
- Responses to REST calls typically provide a `Message` list of messages. These can be interrogated to determine the appropriate action.
- REST calls may result in a limited number of failure scenarios that require exception handling (e.g. service unavailable). Catch and handle these generically.




#To Be Copied or Removed ...

- OcpRestGlobalExceptionHandler in the framework repository is annotated with **@RestControllerAdvice** which is a new feature of Spring Framework 4.3, an annotation with combined @ControllerAdvice + @ResponseBody. So, @RestControllerAdvice can help us to handle Exception with RestfulApi by a cross-cutting concern solution: @ExceptionHandler. This class handles different exception scenarios as listed below and are converted to ERROR messages with the corresponding Http Status codes shown below:
  
  * IllegalArgumentException  --- HttpStatus.BAD_REQUEST
  * MethodArgumentNotValidException -- HttpStatus.BAD_REQUEST
  * HttpClientErrorException -- HttpStatus.BAD_REQUEST
  * MethodArgumentTypeMismatchException -- HttpStatus.BAD_REQUEST
  * ConstraintViolationException -- HttpStatus.BAD_REQUEST
  * HttpMessageNotReadableException -- HttpStatus.BAD_REQUEST
  * HttpRequestMethodNotSupportedException -- HttpStatus.METHOD_NOT_ALLOWED
  * MediaTypeNotSupportedStatusException -- HttpStatus.UNSUPPORTED_MEDIA_TYPE
  * OcpRuntimeException -- No translation but original exception values are used
  * Exception -- HttpStatus.INTERNAL_SERVER_ERROR
  
  Note that the class OcpRestGlobalExceptionHandler is auto-configured via OcpRestAutoConfiguration.
  
- Invalid inputs are handled at the Resource End Point using JSR 303 Validations and any errors are propagated to  OcpRestGlobalExceptionHandler to be converted as 400(HttpStatus.BAD_REQUEST) Http Status Code in the Response Object.

- ExceptionHandlingUtils can be used to transform the run time exceptions into appropriate OcpRuntimeException class to be handled via OcpRestGlobalExceptionHandler.

## Feign Client

- Feign Client interrogates the Response object to convert the HttpStatus code for the Response. Please see PersonRestClientTester for reference implementation
		
	  @ApiOperation(value = "An endpoint which uses a REST client using Feign to call the remote person by pid operation.")
	  @RequestMapping(value = URL_PREFIX + "/callPersonByPidUsingFeignClient", method = RequestMethod.POST,
			produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)
	  public ResponseEntity<PersonInfoResponse>
			callPersonByPidUsingFeignClient(@RequestBody final PersonInfoRequest personInfoRequest) {

		// use this in case of feign hystrix to test fallback handler invocation
		// NOSONAR ConfigurationManager.getConfigInstance().setProperty("hystrix.command.default.circuitBreaker.forceOpen", "true");
		PersonInfoResponse personInfoResponse = null;

		personInfoResponse = feignPersonClient.personByPid(personInfoRequest); // NOSONAR cannot immediately return
		
		if (personInfoResponse != null) {
			if (personInfoResponse.hasErrors()) {
				return new ResponseEntity<>(personInfoResponse, HttpStatus.BAD_REQUEST);
			} else if (personInfoResponse.hasFatals()) {
				return new ResponseEntity<>(personInfoResponse, HttpStatus.INTERNAL_SERVER_ERROR);
			} else {
				return new ResponseEntity<>(personInfoResponse, HttpStatus.OK);
			}
		} else {
			return new ResponseEntity<>(personInfoResponse, HttpStatus.INTERNAL_SERVER_ERROR);
		}
	}

- If Hystrix is enabled on Feign Client then any exception other than HystrixBadRequestException or its subclasses invoke the FallBack methods. So HystrixBadRequestException or its subclasses being propagated need to be handled on the client side as shown above that are using the Hystrix enabled Feign Client.
	
## Rest Client

- No specific exception handling is required on the client for Rest Client as OcpRestGlobalExceptionHandler does the transformation of exception messages to appropriate error messages. Please refer sample code at PersonRestClientTester class.

	  @ApiOperation(value = "An endpoint which uses a REST client using RestTemplate to call the remote echo operation.")
	  @RequestMapping(value = URL_PREFIX + "/callPersonByPidUsingRestTemplate", method = RequestMethod.POST,
			produces = MediaType.APPLICATION_JSON_VALUE, consumes = MediaType.APPLICATION_JSON_VALUE)
	  public ResponseEntity<PersonByPidDomainResponse>
			callPersonByPidUsingRestTemplate(@RequestBody final PersonByPidDomainRequest personByPidDomainRequest)           {
		// invoke the service using classic REST Template from Spring, but load balanced through Consul
		HttpEntity<PersonByPidDomainRequest> requestEntity = new HttpEntity<>(personByPidDomainRequest);
		ResponseEntity<PersonByPidDomainResponse> exchange = null;
			exchange =
					personUsageRestTemplate.executeURL("http://localhost:8080" + PersonResource.URL_PREFIX + "/pid",
							HttpMethod.POST, requestEntity, new ParameterizedTypeReference<PersonByPidDomainResponse>() {
							});
		LOGGER.info("Invoked os-reference-person service using REST template: " + exchange);
		return exchange;
	  }

